# 面向对象第5天：

## 潜艇游戏第一天：

1. 创建了6个类，创建World类并测试

## 潜艇游戏第二天：

1. 给6个类添加构造方法，并测试

## 潜艇游戏第三天：

1. 设计侦察潜艇数组、鱼雷潜艇数组、水雷潜艇数组、水雷数组、炸弹数组，并测试

2. 设计SeaObject超类，6个类继承超类

3. 给超类设计两个构造方法，6个类分别调用

## 潜艇游戏第四天：

1. 将侦察潜艇数组、鱼雷潜艇数组、水雷潜艇数组，统一组合成SeaObject数组，并测试
2. 在6个类中重写move()，并测试
3. 画窗口：在World类中，共3步------------------不需要掌握，CV大法

   - import JFrame+JPanel
   - 设计World类继承JPanel----------------这一步特别容易忘记
   - main中代码CV大法

## 潜艇游戏第五天：

1. 给类中成员添加访问控制修饰符
2. 设计Images图片类



## 回顾：

1. 向上造型：--------------代码复用
   - 超类型的引用指向派生类的对象
   - 能点出来什么，看引用的类型------------------这是规定
2. 方法的重写(override/overriding)：
   - 发生在父子类中，方法名相同，参数列表相同
   - 重写方法被调用时，看对象的类型------------这是规定
3. 重写与重载的区别：
   - 重写：发生在父子类中，方法名相同，参数列表相同
   - 重载：发生在同一类中，方法名相同，参数列表不同



## 精华笔记：

1. package：声明包

   - 作用：避免类的命名冲突
   - 同包中的类不能同名，但不同包中的类可以同名
   - 类的全称：包名.类名，包名常常有层次结构
   - 建议：包名所有字母都小写

   import：导入类

   - 同包中的类可以直接访问
   - 不同包中的类不能直接访问，若想访问：
     - 先import导入类再使用类------------建议
     - 类的全称----------------------------------太繁琐，不建议

   > 注意：
   >
   > 1. 顺序问题：package----------import-----------class
   >
   > 2. import 包名.*;----表示导入了包中的所有类，但不建议，建议用哪个类就导哪个类
   >
   >    -------因为.*会影响性能

2. 访问控制修饰符：------------------保护数据的安全

   - public：公开的，任何类

   - private：私有的，本类

   - protected：受保护的，本类、派生类、同包类

   - 默认的：什么也不写，本类、同包类

     > 说明：
     >
     > 1. java不建议默认访问权限
     > 2. 类的访问权限只能是public或默认的，类中成员的访问权限如上4种都可以
     > 3. 访问权限由小到大依次为：private<默认的<protected<public

3. final：最终的、不能改变的-----------------单独应用几率低

   - 修饰变量：变量不能被改变
   - 修饰方法：方法不能被重写
   - 修饰类：类不能被继承

4. static：静态的

   - 静态变量：

     - 由static修饰
     - 属于类，存储在方法区中，一份
     - 常常通过类名点来访问
     - 何时用：所有对象所共享的数据(图片、音频、视频等)

   - 静态方法：

     - 由static修饰
     - 属于类，存储在方法区中，一份
     - 常常通过类名点来访问
     - 静态方法中没有隐式this传递，所以不能直接访问实例成员，只能直接访问静态成员
     - 何时用：方法的操作与对象无关----方法中不需要访问对象的属性或行为

   - 静态块：

     - 由static修饰

     - 属于类，在类被加载时自动执行，因为一个类只被加载一次，所以静态块也只执行一次

     - 何时用：加载/初始化静态资源(图片、音频、视频等)

       



## 笔记：

1. package：声明包

   - 作用：避免类的命名冲突
   - 同包中的类不能同名，但不同包中的类可以同名
   - 类的全称：包名.类名，包名常常有层次结构
   - 建议：包名所有字母都小写

   import：导入类

   - 同包中的类可以直接访问
   - 不同包中的类不能直接访问，若想访问：
     - 先import导入类再使用类------------建议
     - 类的全称----------------------------------太繁琐，不建议

2. 访问控制修饰符：------------------保护数据的安全

   - public：公开的，任何类

   - private：私有的，本类

   - protected：受保护的，本类、派生类、同包类

   - 默认的：什么也不写，本类、同包类

     > 说明：
     >
     > 1. java不建议默认访问权限
     > 2. 类的访问权限只能是public或默认的，类中成员的访问权限如上4种都可以
     > 3. 访问权限由小到大依次为：private<默认的<protected<public

     ```java
     class Card{ //银行卡
         private String cardId;  //卡号
         private String cardPwd; //密码
         private double balance; //余额
         
         public boolean payMoney(double money){ //支付金额---收银员可以调用
             if(balance>=money){
                 balance-=money;
                 return true;
             }else{
                 return false;
             }
         }
         public boolean checkPwd(String pwd){ //检测密码--营业员可以调用
             if(pwd和cardPwd相同){
                 return true;
             }else{
                 return false;
             }
         }
     }
     ```

     ```java
     //访问控制符的演示
     public class Aoo {
         public int a;     //任何类
         protected int b;  //本类、派生类、同包类
         int c;            //本类、同包类
         private int d;    //本类
     
         void show(){
             a = 1;
             b = 2;
             c = 3;
             d = 4;
         }
     }
     
     class Boo{ //---------------------演示private
         void show(){
             Aoo o = new Aoo();
             o.a = 1;
             o.b = 2;
             o.c = 3;
             //o.d = 4; //编译错误
         }
     }
     
     package ooday05_vis;
     import ooday05.Aoo;
     public class Coo { //---------------演示同包
         void show(){
             Aoo o = new Aoo();
             o.a = 1;
             //o.b = 2; //编译错误
             //o.c = 3; //编译错误
             //o.d = 4; //编译错误
         }
     }
     
     class Doo extends Aoo{ //跨包继承---------演示protected
         void show(){
             a = 1;
             b = 2;
             //c = 3; //编译错误
             //d = 4; //编译错误
         }
     }
     ```

3. final：最终的、不能改变的-----------------单独应用几率低

   - 修饰变量：变量不能被改变

     ```java
     class Eoo{
         int a = 5;
         final int b = 5;
         void show(){
             a = 55;
             //b = 55; //编译错误，final修饰的变量，不能被改变
         }
     }
     ```

   - 修饰方法：方法不能被重写

     ```java
     class Foo{
         void show(){}
         final void test(){}
     }
     class Goo extends Foo{
         void show(){}
         //void test(){} //编译错误，final修饰的方法，不能被重写
     }
     ```

   - 修饰类：类不能被继承

     ```java
     final class Hoo{}
     //class Ioo extends Hoo{} //编译错误，final的类不能被继承
     class Joo{}
     final class Koo extends Joo{} //正确，不能当老爸，但能当儿子
     ```

4. static：静态的

   - 静态变量：

     - 由static修饰

     - 属于类，存储在方法区中，一份

     - 常常通过类名点来访问

     - 何时用：所有对象所共享的数据(图片、音频、视频等)

       ```java
       //演示静态变量
       class Loo{
           int a;
           static int b;
           Loo(){
               a++;
               b++;
           }
           void show(){
               System.out.println("a="+a+",b="+b);
           }
       }
       
       public class StaticDemo {
           public static void main(String[] args) {
               Loo o1 = new Loo();
               o1.show();
               Loo o2 = new Loo();
               o2.show();
               Loo o3 = new Loo();
               o3.show();
               System.out.println(Loo.b); //常常通过类名点来访问
           }
       }
       ```

       

   - 静态方法：

     - 由static修饰

     - 属于类，存储在方法区中，一份

     - 常常通过类名点来访问

     - 静态方法中没有隐式this传递，所以只能直接访问静态成员，而不能直接访问实例成员

     - 何时用：方法的操作与对象无关----方法中不需要访问对象的属性或行为

       ```java
       //演示静态方法
       class Moo{
           int a; //实例变量(对象来访问)
           static int b; //静态变量(类名来访问)
           void show(){ //有隐式this
               System.out.println(this.a);
               System.out.println(Moo.b);
           }
           static void test(){ //没有隐式this
               //静态方法中没有隐式this传递
               //没有this就意味着没有对象
               //而实例成员a必须通过对象来访问
               //所以如下语句会发生编译错误
               //System.out.println(a); //编译错误
               System.out.println(Moo.b);
           }
       }
       //演示静态方法的应用场景
       class Noo{
           int a; //实例变量---描述对象的属性
           //show()方法中需要访问对象的属性a，说明show()的操作与对象有关---不能静态方法
           void show(){
               System.out.println(a);
           }
           //plus()方法中不需要访问对象的属性和行为，说明plus()的操作与对象无关-可以静态方法
           static void plus(int num1,int num2){
               int num=num1+num2;
               System.out.println(num);
           }
       }
       public class StaticDemo {
           public static void main(String[] args) {
               Noo.plus(5,7); //常常通过类名点来访问
           }
       }
       ```

       

   - 静态块：

     - 由static修饰

     - 属于类，在类被加载时自动执行，因为一个类只被加载一次，所以静态块也只执行一次

     - 何时用：加载/初始化静态资源(图片、音频、视频等)

       ```java
       //演示静态块
       class Poo{
           static{
               System.out.println("静态块");
           }
           Poo(){
               System.out.println("构造方法");
           }
       }
       public class StaticDemo {
           public static void main(String[] args) {
               Poo o4 = new Poo();
               Poo o5 = new Poo();
           }
       }
       ```

       



## 补充：

1. 访问权限常规设置模式：

   - 数据(成员变量)私有化(private)
   - 行为(方法)公开化(public)------------------绝大部分方法都是公开的

2. 成员变量分两种：

   - 实例变量：没有static修饰，属于对象的，存储在堆中，有几个对象就有几份

     ?                   通过对象/引用打点来访问

   - 静态变量：有static修饰，属于类的，存储在方法区中，只有一份

     ?                   常常通过类名点来访问

3. 内存管理：由JVM来管理的

   - 堆：new出来的对象(包括实例变量、数组的元素)
   - 栈：局部变量(包括方法的参数)
   - 方法区：.class字节码文件(包括静态变量、所有方法)

4. 图片：

   ```java
   //  公开的  静态的   图片类型  变量名
       public static ImageIcon sea;
   ```

5. 明日单词：

   ```java
   1)graphics:图像/画笔
   2)PI:圆周率
   3)count:数量
   4)abstract:抽象的
   5)live:活着的
   6)dead:死了的
   7)state:状态
   8)is:是
   9)paint:画
   ```





下个阶段学什么？要做什么项目？

学什么：从7月27号开始，你们要学习API(java中封装好的特别常用类、常用的方法-----零件)

项目：手写web server，手写Spring boot

Spring是你们后面课程的重中之重--------Spring boot、Spring MVC、Spring框架









