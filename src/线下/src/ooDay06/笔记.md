# 面向对象第六天：

## 潜艇游戏第一天：

1. 创建了6个类，创建World类并测试

## 潜艇游戏第二天：

1. 给6个类添加构造方法，并测试

## 潜艇游戏第三天：

1. 设计侦察潜艇数组、鱼雷潜艇数组、水雷潜艇数组、水雷数组、炸弹数组，并测试

2. 设计SeaObject超类，6个类继承超类

3. 给超类设计两个构造方法，6个类分别调用

## 潜艇游戏第四天：

1. 将侦察潜艇数组、鱼雷潜艇数组、水雷潜艇数组，统一组合成SeaObject数组，并测试
2. 在6个类中重写move()，并测试
3. 画窗口：在World类中，共3步------------------不需要掌握，CV大法

    - import JFrame+JPanel
    - 设计World类继承JPanel----------------这一步特别容易忘记
    - main中代码CV大法

## 潜艇游戏第五天：

1. 给类中成员添加访问控制修饰符
2. 设计Images图片类

## 潜艇游戏第六天：--------------要求：看着我的步骤能写出来就OK

1. 设计窗口的宽和高为常量，适当地方做修改

2. 画对象：

   ```java
   1)想画对象需要获取对象的图片，每个对象都得获取图片，
     意味着获取图片行为为共有行为，所以设计在SeaObject超类中，
     每个对象获取图片的代码都是不一样的，所以设计为抽象方法
     ---在SeaObject中设计抽象方法getImage()获取对象的图片
   2)在派生类中重写getImage()获取对象图片
     ---在6个类中重写getImage()
   3)因为只有活着的对象才需要画到窗口中，所以需要设计对象的状态(活着还是死了),
     每个对象都有状态，意味着状态为共有属性，所以设计在SeaObject超类中，
     状态一般都设计为常量，同时再设计state变量表示当前状态
     ---在SeaObject中设计LIVE、DEAD常量，state变量表示当前状态
     在后期的业务中经常需要判断对象的状态，每个对象都得判断，
     意味着判断状态的行为为共有行为，所以设计在SeaObject超类中，
     每个对象判断状态的代码都是一样的，所以设计为普通方法
     ---在SeaObject中设计isLive()、isDead()判断对象的状态
   4)数据(状态、图片、x坐标、y坐标)都有了就可以开画了，每个对象都得画，
     意味着画对象的行为为共有行为，所以设计在SeaObject超类中，
     每个对象画的代码都是一样的，所以设计为普通方法
     ---在SeaObject中设计paintImage()画对象
   5)画对象的行为写好了，在窗口World类中调用即可
     5.1)准备对象
     5.2)重写paint()方法----在paint()中调用paintImage()画对象方法即可---------不要求掌握
   ```

## 回顾：

1. package和import：

2. 访问控制修饰符：-------------保护数据的安全

    - public：公开的，任何类
    - private：私有的，本类
    - protected：受保护的，本类、派生类、同包类
    - 默认的：什么也不写，本类、同包类

3. final：最终的，不能改变的

    - 修饰变量：变量不能被改变
    - 修饰方法：方法不能被重写
    - 修饰类：类不能被继承

4. static：静态的

    - 静态变量：static、类、方法区中、一份，类名点来访问

      ​ 所有对象所共享的数据(图片、音频、视频等)

    - 静态方法：static、类、方法区中、一份，类名点来访问，没有this，不能直接访问实例成员

      ​ 方法的操作与对象无关-----不需要访问对象的属性和行为

    - 静态块：static、类、类被加载时自动执行，一次

      ​ 初始化静态资源(图片、音频、视频等)

## 精华笔记：

1. static final常量：应用率高
    - 必须声明同时初始化
    - 由类名打点来访问，不能被改变
    - 建议：常量所有字母都大写，多个单词用_分隔
    - 编译器在编译时会将常量直接替换为具体的数，效率高
    - 何时用：数据永远不变，并且经常使用
2. 抽象方法：
    - 由abstract修饰
    - 只有方法的定义，没有具体的实现(连{}都没有)
3. 抽象类：
    - 由abstract修饰
    - 包含抽象方法的类必须是抽象类
    - 抽象类不能被实例化(new对象)
    - 抽象类是需要被继承的，派生类：
        - 重写抽象方法---------------变不完整为完整
        - 也声明为抽象类------------一般不这么用
    - 抽象类的意义：
        - 封装共有的属性和行为-------------------代码复用
        - 为所有派生类提供统一的类型----------向上造型(代码复用)
        - 可以包含抽象方法，为所有派生类提供统一的入口(向上造型后能点出来)，同时可以达到强制必须重写的目的(相当于制定了一个标准)

## 补充：

1. 设计规则：

    - 将派生类所共有的属性和行为，抽到超类中-------------抽共性

    - 若派生类的行为(实现代码)都一样，设计为普通方法

      若派生类的行为(实现代码)都不一样，设计为抽象方法

    - 。。。。下周二讲

2. 抽象方法/抽象类的疑问：

    - 抽象方法存在的意义是什么？
        - 保证当发生向上造型时，通过超类的引用能点出来那个方法-------保证能点出方法来
    - 既然抽象方法的意义是保证能点出来，那为什么不设计为普通方法呢？
        - 设计为普通方法，意味着派生类可以重写也可以不重写，但设计为抽象方法，则可以强制派生类必须重写--------达到强制派生类重写，统一的目的

3. 画对象带数：先找main

    - 当创建(new)World对象时，就会分配World类中的成员变量(ship,submarines,mines,bombs)

    - frame.setVisible(true);时会自动调用paint()方法，在paint()
      中：当第1次用到Images类时，会将Images.class加载到方法区中，同时将那一堆静态图片分配到方法区中，同时自动执行静态块给图片赋值

    - ship.paintImage(g);时会去调用paintImage()方法，方法中的this指的就是ship战舰，方法中在判断战舰是否是活着的，若活着则获取战舰的图片，用画笔给画到战舰的x和y坐标上

      submarines[i].paintImage(g);时会去调用paintImage()方法，假设submarines[i]
      为侦察潜艇对象，则方法中的this指的就是侦察潜艇，方法中在判断侦察潜艇是否是活着的，若活着则获取侦察潜艇的图片，用画笔画到侦察潜艇的x和y坐标上 。假设submarines[i]为侦察潜艇对象......

4. 明日单词：

   ```java
   1)inner:内部的
   2)outer:外部的
   3)baby:孩子
   4)create:创建
   5)anonymous/anon:匿名
   6)shoot:射击
   7)next:下
   8)one:一个
   9)action:行动
   10)enter:进入
   11)timer:定时器
   12)interval:间隔
   13)schedule:日程表
   14)task:任务
   15)repaint:重新画
   ```

   

