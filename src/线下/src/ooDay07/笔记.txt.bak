
潜艇游戏第七天:
1.潜艇入场:
  1)潜艇是由窗口产生的，所以在World类中设计nextSubmarine()生成潜艇对象
  2)潜艇入场为定时发生的，所以在run()中调用submarineEnterAction()实现潜艇入场
    在submarineEnterAction()中:
      每400毫秒，获取潜艇对象obj，submarines扩容，将obj添加到最后一个元素上
    注意:在run()中调用submarineEnterAction()之后，需要调用repaint()重画

2.水雷入场：
  1)水雷是由水雷潜艇发射出来的，所以在MineSubmarine中设计nextMine()生成水雷对象
  2)水雷入场为定时发生的，所以在run()中调用mineEnterAction()实现水雷入场
    在mineEnterActioin()中:
      每1000毫秒，......暂时搁置

3.海洋对象移动:
  1)海洋对象移动为共有行为，所以在SeaObject中设计抽象方法move()实现移动，
    在6个类中重写move()
  2)海洋对象移动为定时发生的，所以在run()中调用moveAction()实现海洋对象移动
    在moveAction()中:
      遍历所有潜艇，潜艇move()，遍历所有水雷水雷move()，遍历所有炸弹炸弹move()



一.精华笔记:
  1)成员内部类: 应用率不高
    1.1)类中套类，外面的称为外部类，里面的称为内部类
    1.2)内部类通常只服务于外部类，对外不具备可见性
    1.3)内部类对象通常在外部类中创建
    1.4)内部类中可以直接访问外部类的成员(包括私有的)
        内部类中有一个隐式的引用，指向了创建它的外部类对象
        ---外部类名.this---------------要记住(传奇老师那用)

  2)匿名内部类:----------大大简化代码的操作
    2.1)若想创建一个类(派生类)的对象，并且对象只被创建一次，
        此时可以设计为匿名内部类
    2.2)在匿名内部类中不能修饰外面局部变量的值，
        因为该变量在此处会默认为final的----------记住它(传奇才师那用)
    2.3)问:内部类有独立的.class吗?
        答:有

一.笔记:
  1)成员内部类: 应用率不高
    1.1)类中套类，外面的称为外部类，里面的称为内部类
    1.2)内部类通常只服务于外部类，对外不具备可见性
    1.3)内部类对象通常在外部类中创建
    1.4)内部类中可以直接访问外部类的成员(包括私有的)
        内部类中有一个隐式的引用，指向了创建它的外部类对象
        ---外部类名.this---------------要记住(传奇老师那用)
    ```java
    public class InnerClassDemo {
      public static void main(String[] args) {
        Mama m = new Mama();
        //Baby b = new Baby(); //编译错误，内部类对外不具备可见性
      }
    }

    class Mama{ //外部类
      private String name;
      void create(){
        Baby b = new Baby();
      }
      class Baby{ //内部类
        void showName(){
            System.out.println(name); //简便写法
            System.out.println(Mama.this.name); //完整写法
            //System.out.println(this.name); //编译错误，this指代当前Baby对象
        }
      }
    }
    ```

  2)匿名内部类:----------大大简化代码的操作
    2.1)若想创建一个类(派生类)的对象，并且对象只被创建一次，
        此时可以设计为匿名内部类
    2.2)在匿名内部类中不能修饰外面局部变量的值，
        因为该变量在此处会默认为final的----------记住它(传奇才师那用)
    2.3)问:内部类有独立的.class吗?
        答:有
    ```java
    public class NstInnerClassDemo {
      public static void main(String[] args) {
        //1)系统自动创建了Aoo的一个派生类，但是没有名字
        //2)为该派生类创建了一个对象，名为o1
        //  ---new Aoo(){}是在创建Aoo的派生类的对象
        //3)大括号中的为派生类的类体
        Aoo o1 = new Aoo(){
        };

        //1)系统自动创建了Aoo的一个派生类，但是没有名字
        //2)为该派生类创建了一个对象，名为o2
        //3)大括号中的为派生类的类体
        Aoo o2 = new Aoo(){
        };


        //1)系统自动创建了Boo的一个派生类，但是没有名字
        //2)为该派生类创建了一个对象，名为o3
        //3)大括号中的为派生类的类体
        Boo o3 = new Boo(){
            void show(){
                System.out.println("showshow");
            }
        };
        o3.show();


        int num = 5;
        num = 55;
        Boo o4 = new Boo(){
            void show(){
                System.out.println("showshow");
                //num = 66; //编译错误，匿名内部类中不能修改外面局部变量的值，
                            //因为在此处该变量会默认为final的
            }
        };

      }
  }

  abstract class Boo{
    abstract void show();
  }

  abstract class Aoo{
  }
    ```


二.补充:
   1.隐式的引用:
     1)this:指代当前对象
     2)super:指代当前对象的超类对象
     3)外部类名.this:指代当前对象的外部类对象
   2.做功能的套路:
     1)先写行为/方法:
       1.1)若为派生类所特有的行为，则将方法设计在特定的类中
       1.2)若为所有派生类所共有的行为，则将方法设计在超类中
     2)窗口调用:
       2.1)若为定时(自动)发生的，则在定时器中调用
       2.2)若为事件触发的，则在侦听器中调用-----------明天第1节课讲
   3.调用方法的注意事项:
     1)若方法是有返回值的，则必须声明对应类型的变量来接收
     2)调用时:
       2.1)若与方法在同一个类中，则可以直接调用
       2.2)若与方法不在同一个类中，则需要通过引用名打点来调用
       2.3)若方法为静态的，则直接通过类名打点来调用
   4.错误分类:
     1)编译错误----都是由于违反语法规则了
     2)异常--------运行时发生，找到at后的链接点击
     3)程序的运行结果与你所预期的结果不同------------必须得调错
   5.如何调错:
     1)------------明天讲
     2)打桩: System.out.println(数据);
   6.明日单词:
     1)interface:接口
     2)implements:实现
     3)enemy:敌人
     4)nuclear:核武器
     5)left:左
     6)right:右
     7)out of bounds:超出界限
     8)Key:键盘
     9)Adapter:适配器
     10)release:松开/弹起
     11)code:编码
     12)space:空白
     13)listener:监听
       

